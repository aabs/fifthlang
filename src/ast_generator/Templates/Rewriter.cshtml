@model ast_generator.TemplateModel
@using ast_model
@{
    var genNs = Model.NamespaceScope + "_generated";
    var asts = Model.ConcreteTypes;
}
namespace @genNs;
using @Model.NamespaceScope;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Result of rewriting an AST node, carrying the rewritten node and any statements that should be hoisted.
/// </summary>
public record RewriteResult(AstThing Node, List<Statement> Prologue)
{
    /// <summary>
    /// Creates a RewriteResult with no prologue statements.
    /// </summary>
    public static RewriteResult From(AstThing node) => new(node, []);
}

/// <summary>
/// Interface for AST rewriting with statement-level desugaring support.
/// </summary>
public interface IAstRewriter
{
    RewriteResult Rewrite(AstThing ctx);
@foreach (var ast in asts)  
{
@:    RewriteResult Visit@(ast.Name)(@(ast.Name) ctx);
}
}

/// <summary>
/// Default AST rewriter that performs structure-preserving rewrites while aggregating prologue statements.
/// Prologue statements are hoisted upward until consumed by a BlockStatement.
/// </summary>
public class DefaultAstRewriter : IAstRewriter
{
    public virtual RewriteResult Rewrite(AstThing ctx)
    {
        if(ctx == null) return RewriteResult.From(ctx);
        return ctx switch
        {
@foreach (string astNodeType in asts.Select(a=>a.Name))  
{
@:             @(astNodeType) node => Visit@(astNodeType)(node),
}

            { } node => RewriteResult.From(null),
        };
    }

@foreach (var ast in asts)
{
    var allProps = Model.VisitableProperties[ast];
@:    public virtual RewriteResult Visit@(ast.Name)(@(ast.Name) ctx)
@:    {
@if (ast.Name == "BlockStatement")
{
@:        // BlockStatement consumes prologue: splice hoisted statements into the block
@:        List<Statement> outStatements = [];
@:        foreach (var st in ctx.Statements)
@:        {
@:            var rr = Rewrite(st);
@:            outStatements.AddRange(rr.Prologue);
@:            outStatements.Add((Statement)rr.Node);
@:        }
@:        return new RewriteResult(ctx with { Statements = outStatements }, []);
}
else
{
@:        var prologue = new List<Statement>();
@foreach(var prop in allProps.Where(p => p.PropertyType.IsCollectionType()))
{
    var varName = $"tmp{prop.Name}";
    var propTypeName = prop.PropertyType.BuildTypeName();
    var propInstTypeName = prop.PropertyType.TypeParameter(0);
@:        @(propTypeName) @(varName) = [];
@:        foreach (var item in ctx.@(prop.Name))
@:        {
@:            var rr = Rewrite(item);
@:            @(varName).Add((@(propInstTypeName))rr.Node);
@:            prologue.AddRange(rr.Prologue);
@:        }
}
@foreach(var prop in allProps.Where(p => !p.PropertyType.IsCollectionType()))
{
    var varName = $"rr{prop.Name}";
    var propTypeName = prop.PropertyType.BuildTypeName();
@:        var @(varName) = Rewrite((AstThing)ctx.@(prop.Name));
@:        prologue.AddRange(@(varName).Prologue);
}
@:        var rebuilt = ctx with {
    var sep = " ";
    foreach (var prop in allProps)
    {
        if(prop.PropertyType.IsCollectionType())
        {
        var varName = $"tmp{prop.Name}";
@:        @(sep)@(prop.Name) = @(varName)
        }
        else
        {
            var varName = $"rr{prop.Name}";
            var propTypeName = prop.PropertyType.BuildTypeName();
@:        @(sep)@(prop.Name) = (@(propTypeName))@(varName).Node
        }
        sep = ",";
    }
@:        };
@:        return new RewriteResult(rebuilt, prologue);
}
@:    }
}

}
