using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AstSourceGenerators;

[Generator]
public class AstBuildersGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get all type declarations from the compilation
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,
                transform: static (ctx, _) => GetTypeInfo(ctx))
            .Where(static m => m is not null)
            .Collect();

        // Register the source output
        context.RegisterSourceOutput(typeDeclarations, (sourceContext, types) =>
        {
            // First, let's output a diagnostic file to see what types we're finding
            var diagnosticSb = new StringBuilder();
            diagnosticSb.AppendLine("// Diagnostic output from AstBuildersGenerator");
            diagnosticSb.AppendLine($"// Found {types.Length} types total");
            diagnosticSb.AppendLine();

            foreach (var type in types)
            {
                if (type.HasValue)
                {
                    var t = type.Value;
                    diagnosticSb.AppendLine($"// Type: {t.Name} ({t.FullName})");
                    diagnosticSb.AppendLine($"//   Namespace: {t.Namespace}");
                    diagnosticSb.AppendLine($"//   IsAbstract: {t.IsAbstract}");
                    diagnosticSb.AppendLine($"//   IsAstType: {t.IsAstType}");
                    diagnosticSb.AppendLine($"//   Properties: {t.Properties.Length}");
                    foreach (var prop in t.Properties)
                    {
                        diagnosticSb.AppendLine($"//     - {prop.Name}: {prop.TypeName} (Collection: {prop.IsCollection})");
                    }
                    diagnosticSb.AppendLine();
                }
            }

            sourceContext.AddSource("diagnostic.generated.cs", SourceText.From(diagnosticSb.ToString(), Encoding.UTF8));

            var astTypes = types.Where(t => t.HasValue && t.Value.IsAstType).Select(t => t.Value).ToImmutableArray();
            
            if (astTypes.Length > 0)
            {
                var source = GenerateBuilders(astTypes);
                sourceContext.AddSource("builders.generated.cs", SourceText.From(source, Encoding.UTF8));
            }
        });
    }

    private static TypeInfo? GetTypeInfo(Microsoft.CodeAnalysis.GeneratorSyntaxContext context)
    {
        var typeSymbol = context.SemanticModel.GetDeclaredSymbol(context.Node) as INamedTypeSymbol;
        if (typeSymbol == null) return null;

        // Check if this is an AST type (inherits from AstThing or is in ast namespace)
        bool isAstType = IsAstType(typeSymbol);
        if (!isAstType) return null;

        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && p.SetMethod?.IsInitOnly == true)
            .Select(p => new PropertyInfo(
                name: p.Name,
                typeName: p.Type.ToDisplayString(),
                isCollection: IsCollectionType(p.Type),
                declaringTypeName: p.ContainingType.Name))
            .ToImmutableArray();

        return new TypeInfo(
            name: typeSymbol.Name,
            fullName: typeSymbol.ToDisplayString(),
            @namespace: typeSymbol.ContainingNamespace.ToDisplayString(),
            isAbstract: typeSymbol.IsAbstract,
            isAstType: isAstType,
            properties: properties);
    }

    private static bool IsAstType(INamedTypeSymbol typeSymbol)
    {
        // Check if type is in ast namespace
        if (typeSymbol.ContainingNamespace.ToDisplayString() == "ast")
            return true;

        // Check if inherits from AstThing
        var currentType = typeSymbol.BaseType;
        while (currentType != null)
        {
            if (currentType.Name == "AstThing")
                return true;
            currentType = currentType.BaseType;
        }

        return false;
    }

    private static bool IsCollectionType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol namedType && namedType.IsGenericType)
        {
            var typeName = namedType.ConstructedFrom.ToDisplayString();
            return typeName.Contains("List<") || typeName.Contains("LinkedList<");
        }
        return false;
    }

    private static string GenerateBuilders(ImmutableArray<TypeInfo> astTypes)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// Generated by AstBuildersGenerator");
        sb.AppendLine();
        sb.AppendLine("namespace ast_generated;");
        sb.AppendLine("using ast_generated;");
        sb.AppendLine("using ast;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();

        foreach (var type in astTypes.Where(t => !t.IsAbstract))
        {
            GenerateBuilder(sb, type);
        }

        sb.AppendLine("#nullable restore");
        return sb.ToString();
    }

    private static void GenerateBuilder(StringBuilder sb, TypeInfo type)
    {
        sb.AppendLine($"public class {type.Name}Builder : IBuilder<{type.FullName}>");
        sb.AppendLine("{");
        sb.AppendLine();

        // Generate private fields
        foreach (var prop in type.Properties)
        {
            sb.AppendLine($"    private {prop.TypeName} _{prop.Name};");
        }

        sb.AppendLine();
        sb.AppendLine($"    public {type.FullName} Build()");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {type.FullName}(){{");

        var first = true;
        foreach (var prop in type.Properties)
        {
            var separator = first ? " " : ",";
            sb.AppendLine($"           {separator} {prop.Name} = this._{prop.Name} // from {prop.DeclaringTypeName}");
            first = false;
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");

        // Generate With methods
        foreach (var prop in type.Properties)
        {
            sb.AppendLine($"    public {type.Name}Builder With{prop.Name}({prop.TypeName} value){{");
            sb.AppendLine($"        _{prop.Name} = value;");
            sb.AppendLine("        return this;");
            sb.AppendLine("    }");
            sb.AppendLine();

            // Generate AddingItemTo methods for collections
            if (prop.IsCollection)
            {
                var elementType = GetCollectionElementType(prop.TypeName);
                sb.AppendLine($"    public {type.Name}Builder AddingItemTo{prop.Name}({elementType} value){{");
                sb.AppendLine($"        _{prop.Name}  ??= [];");
                sb.AppendLine($"        _{prop.Name}.Add(value);");
                sb.AppendLine("        return this;");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static string GetCollectionElementType(string typeName)
    {
        // Extract element type from List<T> or LinkedList<T>
        var start = typeName.IndexOf('<');
        var end = typeName.LastIndexOf('>');
        if (start > 0 && end > start)
        {
            return typeName.Substring(start + 1, end - start - 1);
        }
        return "object";
    }

    private struct TypeInfo
    {
        public string Name { get; }
        public string FullName { get; }
        public string Namespace { get; }
        public bool IsAbstract { get; }
        public bool IsAstType { get; }
        public ImmutableArray<PropertyInfo> Properties { get; }

        public TypeInfo(string name, string fullName, string @namespace, bool isAbstract, bool isAstType, ImmutableArray<PropertyInfo> properties)
        {
            Name = name;
            FullName = fullName;
            Namespace = @namespace;
            IsAbstract = isAbstract;
            IsAstType = isAstType;
            Properties = properties;
        }
    }

    private struct PropertyInfo
    {
        public string Name { get; }
        public string TypeName { get; }
        public bool IsCollection { get; }
        public string DeclaringTypeName { get; }

        public PropertyInfo(string name, string typeName, bool isCollection, string declaringTypeName)
        {
            Name = name;
            TypeName = typeName;
            IsCollection = isCollection;
            DeclaringTypeName = declaringTypeName;
        }
    }
}

