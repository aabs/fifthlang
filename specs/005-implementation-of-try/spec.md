# Feature Specification: Implementation of try/catch/finally control flow

**Feature Branch**: `005-implementation-of-try`  
**Created**: 2025-10-12  
**Status**: Draft  
**Input**: User description: "Implementation of try/catch/finally control flow

This specification is for the implementation of try catch finally control flow within the fifth language.

The syntax and semantics will be exactly identical to that used by C#.

The IL generation will be generated to be as close as possible to that generated by the roslyn compiler for C#."

## Execution Flow (main)
```
1. Parse user description from Input
   → If empty: ERROR "No feature description provided"
2. Extract key concepts from description
   → Identify: actors, actions, data, constraints
3. For each unclear aspect:
   → Mark with [NEEDS CLARIFICATION: specific question]
4. Fill User Scenarios & Testing section
   → If no clear user flow: ERROR "Cannot determine user scenarios"
5. Generate Functional Requirements
   → Each requirement must be testable
   → Mark ambiguous requirements
6. Identify Key Entities (if data involved)
7. Run Review Checklist
   → If any [NEEDS CLARIFICATION]: WARN "Spec has uncertainties"
   → If implementation details found: ERROR "Remove tech details"
8. Return: SUCCESS (spec ready for planning)
```

---

## ⚡ Quick Guidelines
- Audience: Compiler and runtime engineers implementing the Fifth language's exception handling. This spec intentionally contains technical requirements and implementation-focused acceptance criteria.
- Goal: Provide a precise, testable specification so that the parser, AST, semantic analyzer and IL emitter can be implemented and verified to match C# behaviour.
- Note: The spec asserts 'identical to C#' semantics. C# version chosen: latest stable C# at implementation time. Other open design choices (async/await interaction, identifier-keyword conflicts) remain marked as [NEEDS CLARIFICATION].

### Section Requirements
- **Mandatory sections**: Completed below for this feature.

## Clarifications

### Session 2025-10-12

- Q: Which exact C# language version semantics are we matching? → A: E — Match latest stable C# at implementation time
- Q: Keyword handling: reserve `try`, `catch`, `finally`, and `when` as hard keywords, or make them contextual? → A: A — Reserve as hard keywords (breaking change)
- Q: Async/await interaction: must the transformed async state-machine IL match Roslyn byte-for-byte or only preserve observable behavior? → A: A — Match Roslyn IL byte-for-byte
- Q: Exception identifier scoping in catch filters: which scoping should we follow? → A: A — Match C# (identifier in filter and catch body)
- Q: Should exception bindings use C#-style `Type id` syntax or Fifth-style `id: Type`? → A: Use Fifth `id: Type` syntax for exception bindings; allow `catch (Type)` as an unnamed typed catch.
- Q: How should the Fifth exception model map to the target runtime (CLR)? → A: A — Map directly to CLR types (use System.Exception family)

---

## User Scenarios & Testing *(mandatory)*

### Primary User Story
As a Fifth language programmer I want to write exception-handling blocks using C#-style syntax so that existing C# exception handling idioms (try, multiple catches, exception filters, finally, rethrow semantics) behave the same in Fifth and are portable with minimal changes.

### Acceptance Scenarios
1. Parsing and AST construction
   - Given a valid try/catch/finally block using C# semantics and Fifth-style exception binding (`catch (ex: Type)`), when the parser runs, then the parser accepts the input and the AstBuilder produces a `TryStatement` node whose children represent the try block, zero-or-more catch clauses (each with optional exception type, optional exception identifier, optional filter expression), and an optional finally block.

2. Catch selection & filters
   - Given an exception thrown inside the try block and multiple catch clauses, when the runtime selects a catch, then it should select the first catch clause whose type is assignment-compatible with the thrown exception and whose filter (when present) evaluates to true. Filters are evaluated in order and evaluated before the body of the matching catch executes.

3. Rethrow semantics
   - Given a catch block that executes `throw;`, when re-throwing, the original exception's stack trace and dispatch information are preserved. Given `throw ex;` (rethrowing the caught identifier), the implementation may update the stack (same semantics as current C# behaviour).

4. Finally semantics
   - Given a try block with a finally clause, the finally clause executes in all control-flow exit paths from the try and any matching catch (normal return, throw, break/continue where applicable). If finally itself throws, its exception propagates according to normal C# rules.

5. Async interaction (example scenario)
   - Given an async method containing a try/catch/finally block, exceptions raised across await boundaries are observed and handled with the same C# semantics after the async transformation.
   - The transformed async state-machine IL MUST match Roslyn's IL byte-for-byte for methods containing try/catch/finally across await boundaries. The IL-emitter must reproduce Roslyn's state-machine structure, opcodes, handler regions, and local layout for these cases; tests must compare textual IL output against Roslyn's output for representative samples.

### Edge Cases
- Nested try/catch/finally blocks and ordering of finally execution when multiple nested returns/throws occur.
- Catch clauses with no declared exception type (i.e., `catch { ... }`) and with explicit type (`catch (System.Exception ex) { ... }`).
- Exception filters that throw during evaluation. The implementation will match C# behaviour: if a filter throws, the exception propagates and is handled according to C# semantics (filter exceptions do not cause the filter to be ignored; they may be observed as separate failures). [Note: exact behavior matched to latest stable C# version.]
- Catch type that is not an exception type (compiler error: "catch type must be assignable to System.Exception").
- Re-throwing and preservation of ExceptionDispatchInfo for call-sites.

---

## Requirements *(mandatory)*

### Functional Requirements
- **FR-001**: Parser MUST accept C#-style try/catch/finally constructs (semantics) while using Fifth-style exception-binding syntax for declared identifiers. The grammar must support:
  - `catch` with no parentheses (catch-all) as in `catch { ... }`;
  - `catch (id: Type)` where `id` is an identifier and `Type` is a type expression (Fifth-style binding);
  - `catch (Type)` as an unnamed typed catch (no identifier bound);
  - `catch (id: Type) when (boolean-expression)` exception filters (where the filter may reference `id`).

- **FR-002**: AST MUST introduce a `TryStatement` node with the following structure (fields are illustrative, tests shall use canonical names agreed in `AstMetamodel`):
  - `Block TryBlock` (required)
  - `List<CatchClause> CatchClauses` (ordered)
  - `Block? FinallyBlock` (optional)

  Each `CatchClause` must contain:
  - `Type? ExceptionType` (optional)
  - `Identifier? ExceptionIdentifier` (optional)
  - `Expression? Filter` (optional)
  - `Block Body`

  Parsing note: when the grammar produces `catch (id: Type)` the parser must populate `ExceptionIdentifier` first and `ExceptionType` second; when the grammar produces `catch (Type)` the parser must populate `ExceptionType` and leave `ExceptionIdentifier` unset.

- **FR-003**: Semantic analysis MUST enforce:
  - If `ExceptionType` is present it must be a reference type compatible with the runtime exception base type (e.g., `System.Exception`). If not compatible: compile-time error.
  - Filter expressions must be boolean-convertible; filter evaluation semantics must match the latest stable C# semantics at implementation time (filter evaluated before the catch body). The exception identifier declared in a catch clause is in scope both within the filter expression and the catch body, matching C# scoping rules.
  - ExceptionType mapping: Fifth exception types must map to CLR exception types. The semantic analyzer must ensure that any declared `ExceptionType` is convertible to `System.Exception` (or a recognized CLR exception type) and perform necessary type resolution checks. If Fifth supports user-defined exception types, they must emit CLR types compatible with System.Exception.

- **FR-004**: Code generation / IL emission MUST produce exception handler metadata and instruction sequences that are structurally equivalent to Roslyn's output for semantically equivalent source code. Structural equivalence includes:
   - Handler regions layout (try/catch/finally boundaries)
   - Use of `catch` vs `filter` clauses in metadata where C# uses filters
   - Correct use of `leave`, `endfinally`, `throw` and `rethrow` opcodes
   - Correct ordering and scoping of local variables used to store the caught exception

  Exact textual IL match is not required for non-async constructs; tests will validate structural equivalence using normalized comparisons (handler regions, handler kinds, opcodes in critical places, and the presence/position of `leave`/`endfinally` opcodes). Exception: for async state-machine rewrites for methods that contain try/catch/finally across await points, the emitter MUST produce IL that matches Roslyn's IL byte-for-byte. The emitter must include a test-harness that compiles equivalent C# samples with Roslyn and compares the produced IL textually for these async cases.

- **FR-005**: Runtime semantics MUST match C# behaviour for:
  - Catch selection order and filter evaluation
  - `throw;` versus `throw ex;` semantics (stack-trace preservation vs reset)
  - Finally execution in all control-flow exit paths
  - Exceptions thrown inside catch or finally behave as in C# (they propagate according to the normal exception propagation rules)

- **FR-006**: Diagnostics and error messages MUST be clear and actionable:
  - Using a non-exception type in a catch clause must produce a specific diagnostic, e.g., "catch type must derive from System.Exception".
  - Unused catch variables or unreachable catch blocks should produce helpful warnings consistent with existing diagnostics styles.

- **FR-007**: Tests MUST include parsing tests, AST construction tests, semantic validation tests, IL-emission structural tests, and end-to-end runtime tests (integration tests). Each requirement above must have at least one automated test covering the normal and edge-case behaviour.

- **FR-008**: Backwards compatibility: Resolved — the team will reserve `try`, `catch`, `finally`, and `when` as hard keywords (breaking change). Implementation work must include documentation updates and a migration note in the release notes identifying potential source breakages and suggested remediation steps.

### Key Non-functional Requirements
- **NFR-001**: The normal (non-exceptional) execution path should incur minimal overhead relative to current codegen. Exception handling support must not degrade performance for code that does not throw exceptions.
- **NFR-002**: The IL emitter MUST produce handler metadata compatible with the runtime (CLR-style handlers if targeting .NET). The emitter should use the canonical instructions (`leave`, `endfinally`, `throw`, `rethrow` or their equivalents) that the target VM expects. For async state-machine rewrites involving try/catch/finally, the IL emitter MUST match Roslyn's IL byte-for-byte.

### Key Entities *(this feature involves AST/IR entities)*
- **TryStatement**: Represents the top-level try node in AST.
- **CatchClause**: Represents each catch with optional type, identifier and filter.
- **FinallyBlock**: Block executed on exit from try/catch.
- **ExceptionDispatch semantics**: (internal concept) tracking semantics necessary to preserve stack traces on rethrow.

---

## Review & Acceptance Checklist
*GATE: Implementation is not considered complete until all items below are satisfied by automated tests and code review.*

### Content Quality
- [x] Feature name and user intent are clear
- [x] Input (user description) preserved
- [ ] All mandatory spec sections completed (this file)

### Requirement Completeness
- [ ] No remaining [NEEDS CLARIFICATION] markers (owner must resolve before implementation)
- [ ] Requirements are testable and have associated tests
- [ ] Success criteria are measurable (parser/AST/IL/runtime tests exist)
- [ ] Scope is clearly bounded (parser + AST + IL + tests + docs)
- [ ] Dependencies and assumptions identified (runtime target, C# version, keyword handling: reserved as hard keywords, exception model mapping: CLR System.Exception)

---

## Execution Status
- [x] User description parsed
- [x] Key concepts extracted (parser, AST, semantic, IL)
- [x] Ambiguities marked
- [x] User scenarios defined
- [x] Requirements drafted
- [ ] Entities added to `AstMetamodel` (implementation task)
- [ ] Review checklist passed

---

## Implementation Plan (high level tasks)
The tasks below map the minimal work to implement the feature end-to-end. Each task should be split across smaller PRs if necessary; prefer small, reviewable commits.

1. Grammar & Lexer
   - Add keywords/tokens: `try`, `catch`, `finally`, `when` (if not already reserved) to `src/parser/grammar/FifthLexer.g4`.
   - Add a `tryStatement` grammar production to `src/parser/grammar/FifthParser.g4` that mirrors C# try/catch/finally forms but uses Fifth-style exception binding in catch parameters (`catchClause: 'catch' '(' Identifier ':' Type ( 'when' '(' Expression ')' )? ')' | 'catch' '(' Type ')' | 'catch' '{' Block '}'`).
   - Add parser-level tests: `src/parser/grammar/test_samples/try-catch-01.5th`, etc.
   - Add parser-level tests that include `catch (ex: System.Exception)`, `catch (System.Exception)` and `catch { ... }` samples to validate both bound and unnamed typed catches.

2. AST Model
   - Update `src/ast-model/AstMetamodel.cs` to add `TryStatement`, `CatchClause`, and `FinallyBlock` entries.
   - Run generator: `just run-generator` and validate generated builders in `src/ast-generated/`.

3. AST Builder
   - Update `src/parser/AstBuilderVisitor.cs` to construct `TryStatement` nodes including catch clauses and optional filters.
   - Add unit tests under `test/ast-tests/` validating the AST shape for a set of sample inputs.

4. Semantic Analysis
   - Add semantic checks to ensure catch types are compatible with the runtime exception base type and that filter expressions are boolean-convertible.
   - Add diagnostics for invalid catch declarations.

5. IL / PE Emitter
   - Implement code emission in `src/code_generator/PEEmitter.cs` or the existing emitter pipeline to create exception handler regions with appropriate opcodes (`leave`, `endfinally`, `throw`) and metadata (catch/filter/finally). Use Roslyn output as structural reference when authoring tests.
   - Implement the async state-machine emission to reproduce Roslyn's transformation exactly for methods that include try/catch/finally across await points. This includes reproducing local slot layout, synthesized fields, MoveNext method structure, and exception handling boundaries.
   - Add a test harness that compiles the same source with Roslyn and Fifth's emitter and performs a byte-for-byte IL comparison for async cases.

6. Runtime & Integration Tests
   - Add runtime tests under `test/runtime-integration-tests/` that exercise try/catch/finally behaviour (including nested handlers, filters, rethrow behaviour, exceptions in finally, and async interactions).
   - If Fifth has its own runtime beyond CLR, add tests validating equivalent observable behaviour.

7. Docs & Examples
   - Update `docs/syntax-samples-readme.md` and `learn5thInYMinutes.md` with concise try/catch/finally examples.
   - Add sample snippets under `test/` and `src/parser/grammar/test_samples/`.

8. CI & Validation
   - Add parser-checker-friendly samples to the validator's include list. Run `scripts/validate-examples.fish` to ensure new examples parse.
   - Ensure new tests are covered by `dotnet test test/syntax-parser-tests/`, `dotnet test test/ast-tests/`, and `dotnet test test/runtime-integration-tests/` as appropriate.

---

## Testing & Validation Plan (concrete tests)
- Parser tests (syntax-parser-tests):
  - `TryCatchFinally_Syntax_01.5th`: simple try/finally parses
  - `TryCatchFinally_Syntax_02.5th`: multiple catch clauses parse (`catch (ex: System.Exception)`, `catch (System.Exception)`, `catch { }`)
  - `TryCatchFinally_Syntax_03.5th`: catch with filter (`catch (ex: System.Exception) when (ex.Message != null)`) parses

- AST tests (ast-tests):
  - `TryStatement_AstShape_01`: verifies TryBlock, CatchClauses, FinallyBlock are present and typed correctly

- Semantic tests:
  - `CatchNonExceptionType_Error`: using `catch (x: int)` must produce a compile error
  - `FilterMustBeBoolean_Error`: `catch (e: Exception) when (123)` must be a type error
  - `CatchBinding_Syntax`: `catch (e: System.Exception)` populates `ExceptionIdentifier` and `ExceptionType` in the AST as expected.

- IL structural tests:
  - `TryFinally_ILLayout`: Ensure handler regions and `endfinally`/`leave` patterns are present.
  - `TryCatch_Filter_IL`: Ensure `filter` clauses are emitted when source uses `when` and handled structurally like Roslyn.

- Runtime integration tests (runtime-integration-tests):
  - `FinallyAlwaysExecutes`: verifies finally always runs for return/throw paths
  - `RethrowPreservesStackTrace`: `throw;` preserves stack trace while `throw ex;` does not (compare stack traces or use ExceptionDispatchInfo semantics to assert preservation)
  - `ExceptionMapping_Emission`: Fifth exception types are emitted as CLR types derived from System.Exception and validated in IL-emission tests.

---

## Open Questions / Decisions (must be resolved before implementation)
- 1. Keyword handling: reserve `try`, `catch`, `finally`, and `when` as hard keywords, or make them contextual? (back-compat trade-off) — Resolved: reserve as hard keywords (breaking change)
- 2. Async/await interaction: must the transformed state-machine IL match Roslyn byte-for-byte or only preserve observable behaviour? — Resolved: match Roslyn IL byte-for-byte
- 3. Exception filters: confirm whether filters must have access to the exception identifier in the filter expression and the exact scoping rules to follow (match C# semantics) — Resolved: exception identifier is in scope in filter and catch body (match C#)
- 4. If the Fifth runtime differs from CLR, define the mapping between Fifth exception model and the target runtime's exception model — Resolved: map directly to CLR types (use System.Exception family)

---

## Acceptance Criteria (concrete)
- Parser accepts all C#-style try/catch/finally forms in test suite (`syntax-parser-tests` green).
- AST builder produces `TryStatement` nodes and unit tests (`ast-tests`) asserting node shapes pass.
- Semantic analyzer rejects invalid catch-type uses and invalid filter expressions with documented diagnostics.
- IL-emitter structural tests compare the emitted handler metadata, handler kinds and critical opcodes to Roslyn's structural output and pass (allowing non-semantic differences such as local slot indices).
- End-to-end runtime tests (`runtime-integration-tests`) validate observable behaviour: catch selection order, filter semantics, finally execution, and rethrow stack-trace semantics.
- IL-emitter async IL equality tests: For representative async methods containing try/catch/finally across await points, the emitted IL MUST match Roslyn's IL byte-for-byte (textual comparison) and corresponding tests must pass. All thrown Fifth exceptions must be represented as CLR types derived from System.Exception per the mapping decision.

---

## Estimated effort
- Rough estimate (single engineer): 4–8 weeks of focused work, including tests and documentation. Matching Roslyn's async state-machine IL byte-for-byte increases design, testing, and validation effort. Break into small PRs: parser + AST + tests (2–4 days), semantic checks (1–2 days), IL-emitter changes + IL structural and async IL equality tests (2–4 weeks), runtime/integration tests and docs (4–7 days), review/merge/fixups (1–2 weeks).

---

## Next steps
1. Resolve all [NEEDS CLARIFICATION] items with stakeholders.
2. Create small focused PRs per the Implementation Plan, starting with parser + AST + generator run.
3. Add parser and AST unit tests; run `scripts/validate-examples.fish` and the test suites.

---
