# Feature Specification: Implementation of try/catch/finally control flow

**Feature Branch**: `005-implementation-of-try`  
**Created**: 2025-10-12  
**Status**: Draft  
**Input**: User description: "Implementation of try/catch/finally control flow

This specification is for the implementation of try catch finally control flow within the fifth language.

The syntax and semantics will be exactly identical to that used by C#.

The IL generation will be generated to be as close as possible to that generated by the roslyn compiler for C#."

## Execution Flow (main)
```
1. Parse user description from Input
   → If empty: ERROR "No feature description provided"
2. Extract key concepts from description
   → Identify: actors, actions, data, constraints
3. For each unclear aspect:
   → Mark with [NEEDS CLARIFICATION: specific question]
4. Fill User Scenarios & Testing section
   → If no clear user flow: ERROR "Cannot determine user scenarios"
5. Generate Functional Requirements
   → Each requirement must be testable
   → Mark ambiguous requirements
6. Identify Key Entities (if data involved)
7. Run Review Checklist
   → If any [NEEDS CLARIFICATION]: WARN "Spec has uncertainties"
   → If implementation details found: ERROR "Remove tech details"
8. Return: SUCCESS (spec ready for planning)
```

---

## ⚡ Quick Guidelines
- Audience: Compiler and runtime engineers implementing the Fifth language's exception handling. This spec intentionally contains technical requirements and implementation-focused acceptance criteria.
- Goal: Provide a precise, testable specification so that the parser, AST, semantic analyzer and IL emitter can be implemented and verified to match C# behaviour.
- Note: The spec asserts 'identical to C#' semantics. C# version chosen: latest stable C# at implementation time. Other open design choices (async/await interaction, identifier-keyword conflicts) remain marked as [NEEDS CLARIFICATION].

### Section Requirements
- **Mandatory sections**: Completed below for this feature.

## Clarifications

### Session 2025-10-12

- Q: Which exact C# language version semantics are we matching? → A: E — Match latest stable C# at implementation time
- Q: Keyword handling: reserve `try`, `catch`, `finally`, and `when` as hard keywords, or make them contextual? → A: A — Reserve as hard keywords (breaking change)
- Q: Async/await interaction: must the transformed async state-machine IL match Roslyn byte-for-byte or only preserve observable behavior? → A: A — Match Roslyn IL byte-for-byte
- Q: Exception identifier scoping in catch filters: which scoping should we follow? → A: A — Match C# (identifier in filter and catch body)
 - Q: AST modeling approach for this feature: prefer first-class nodes/typed properties or use ad-hoc annotations? → A: Prefer first-class nodes and typed properties; annotations only for marginal, non-semantic metadata
- Q: Should exception bindings use C#-style `Type id` syntax or Fifth-style `id: Type`? → A: Use Fifth `id: Type` syntax for exception bindings; allow `catch (Type)` as an unnamed typed catch.
- Q: How should the Fifth exception model map to the target runtime (CLR)? → A: A — Map directly to CLR types (use System.Exception family)

### Session 2025-11-02

- Q: Iterator interaction with try/catch/finally in v1: allow within iterator/async-iterator methods, restrict to try/finally only, or defer? → A: Defer iterators entirely
 - Q: Performance budget for non-exceptional path: strict percentage target or macro-level no-regression? → A: D — No strict budget; "no measurable regression" on macrobenchmarks
 - Q: Pinning the IL test baseline: tie golden IL comparisons to the .NET SDK in global.json, hard-freeze a specific Roslyn/SDK version, or float to latest? → A: A — Pin to SDK in global.json
 - Q: Unreachable catch diagnostic severity due to ordering/type shadowing? → A: A — Error (compile-time)
 - Q: Throw expressions scope in v1: include C#-style throw expressions (e.g., `x ?? throw new E()`), exclude them, or restrict to certain contexts? → A: A — Include throw expressions in v1 (match C# contexts)

---

## User Scenarios & Testing *(mandatory)*

### Primary User Story
As a Fifth language programmer I want to write exception-handling blocks using C#-style syntax so that existing C# exception handling idioms (try, multiple catches, exception filters, finally, rethrow semantics) behave the same in Fifth and are portable with minimal changes.

### Acceptance Scenarios
1. Parsing and AST construction
   - Given a valid try/catch/finally block using C# semantics and Fifth-style exception binding (`catch (ex: Type)`), when the parser runs, then the parser accepts the input and the AstBuilder produces a `TryStatement` node whose children represent the try block, zero-or-more catch clauses (each with optional exception type, optional exception identifier, optional filter expression), and an optional finally block.

2. Catch selection & filters
   - Given an exception thrown inside the try block and multiple catch clauses, when the runtime selects a catch, then it should select the first catch clause whose type is assignment-compatible with the thrown exception and whose filter (when present) evaluates to true. Filters are evaluated in order and evaluated before the body of the matching catch executes.

3. Rethrow semantics
   - Given a catch block that executes `throw;`, when re-throwing, the original exception's stack trace and dispatch information are preserved. Given `throw ex;` (rethrowing the caught identifier), the implementation may update the stack (same semantics as current C# behaviour).

4. Finally semantics
   - Given a try block with a finally clause, the finally clause executes in all control-flow exit paths from the try and any matching catch (normal return, throw, break/continue where applicable). If finally itself throws, its exception propagates according to normal C# rules.

5. Async interaction (example scenario)
   - Given an async method containing a try/catch/finally block, exceptions raised across await boundaries are observed and handled with the same C# semantics after the async transformation.
   - The transformed async state-machine IL MUST match Roslyn's IL byte-for-byte for methods containing try/catch/finally across await boundaries. The IL-emitter must reproduce Roslyn's state-machine structure, opcodes, handler regions, and local layout for these cases; tests must compare textual IL output against Roslyn's output for representative samples.

### Edge Cases
- Nested try/catch/finally blocks and ordering of finally execution when multiple nested returns/throws occur.
- Catch clauses with no declared exception type (i.e., `catch { ... }`) and with explicit type (`catch (System.Exception ex) { ... }`).
- Exception filters that throw during evaluation. The implementation will match C# behaviour: if a filter throws, the exception propagates and is handled according to C# semantics (filter exceptions do not cause the filter to be ignored; they may be observed as separate failures). [Note: exact behavior matched to latest stable C# version.]
- Catch type that is not an exception type (compiler error: "catch type must be assignable to System.Exception").
- Re-throwing and preservation of ExceptionDispatchInfo for call-sites.
- Iterator and async-iterator contexts are not supported in v1: any `try`/`catch`/`finally` inside iterator methods should trigger the deferral diagnostic.

---

## Requirements *(mandatory)*

### Functional Requirements
- **FR-001**: Parser MUST accept C#-style try/catch/finally constructs (semantics) while using Fifth-style exception-binding syntax for declared identifiers. The grammar must support:
  - `catch` with no parentheses (catch-all) as in `catch { ... }`;
  - `catch (id: Type)` where `id` is an identifier and `Type` is a type expression (Fifth-style binding);
  - `catch (Type)` as an unnamed typed catch (no identifier bound);
  - `catch (id: Type) when (boolean-expression)` exception filters (where the filter may reference `id`).

- **FR-002**: AST MUST introduce a `TryStatement` node with the following structure (fields are illustrative, tests shall use canonical names agreed in `AstMetamodel`):
  - `Block TryBlock` (required)
  - `List<CatchClause> CatchClauses` (ordered)
  - `Block? FinallyBlock` (optional)

  Each `CatchClause` must contain:
  - `Type? ExceptionType` (optional)
  - `Identifier? ExceptionIdentifier` (optional)
  - `Expression? Filter` (optional)
  - `Block Body`

  Parsing note: when the grammar produces `catch (id: Type)` the parser must populate `ExceptionIdentifier` first and `ExceptionType` second; when the grammar produces `catch (Type)` the parser must populate `ExceptionType` and leave `ExceptionIdentifier` unset.

- **FR-003**: Semantic analysis MUST enforce:
  - If `ExceptionType` is present it must be a reference type compatible with the runtime exception base type (e.g., `System.Exception`). If not compatible: compile-time error.
  - Filter expressions must be boolean-convertible; filter evaluation semantics must match the latest stable C# semantics at implementation time (filter evaluated before the catch body). The exception identifier declared in a catch clause is in scope both within the filter expression and the catch body, matching C# scoping rules.
  - ExceptionType mapping: Fifth exception types must map to CLR exception types. The semantic analyzer must ensure that any declared `ExceptionType` is convertible to `System.Exception` (or a recognized CLR exception type) and perform necessary type resolution checks. If Fifth supports user-defined exception types, they must emit CLR types compatible with System.Exception.
   - Unreachable catch detection: a catch clause that is unreachable due to an earlier, broader, or identical type match (or ordering) MUST produce a compile-time error.

- **FR-004**: Code generation / IL emission MUST produce exception handler metadata and instruction sequences that are structurally equivalent to Roslyn's output for semantically equivalent source code. Structural equivalence includes:
   - Handler regions layout (try/catch/finally boundaries)
   - Use of `catch` vs `filter` clauses in metadata where C# uses filters
   - Correct use of `leave`, `endfinally`, `throw` and `rethrow` opcodes
   - Correct ordering and scoping of local variables used to store the caught exception

  Exact textual IL match is not required for non-async constructs; tests will validate structural equivalence using normalized comparisons (handler regions, handler kinds, opcodes in critical places, and the presence/position of `leave`/`endfinally` opcodes). Exception: for async state-machine rewrites for methods that contain try/catch/finally across await points, the emitter MUST produce IL that matches Roslyn's IL byte-for-byte. The emitter must include a test-harness that compiles equivalent C# samples with Roslyn and compares the produced IL textually for these async cases.

- **FR-005**: Runtime semantics MUST match C# behaviour for:
  - Catch selection order and filter evaluation
  - `throw;` versus `throw ex;` semantics (stack-trace preservation vs reset)
  - Finally execution in all control-flow exit paths
  - Exceptions thrown inside catch or finally behave as in C# (they propagate according to the normal exception propagation rules)

- **FR-006**: Diagnostics and error messages MUST be clear and actionable:
  - Using a non-exception type in a catch clause must produce a specific diagnostic, e.g., "catch type must derive from System.Exception".
   - Unreachable catch blocks (due to ordering/type shadowing) MUST be reported as compile-time errors.
   - Unused catch variables SHOULD produce a warning consistent with existing diagnostics styles.

- **FR-007**: Tests MUST include parsing tests, AST construction tests, semantic validation tests, IL-emission structural tests, and end-to-end runtime tests (integration tests). Each requirement above must have at least one automated test covering the normal and edge-case behaviour.

- **FR-008**: Backwards compatibility: Resolved — the team will reserve `try`, `catch`, `finally`, and `when` as hard keywords (breaking change). Implementation work must include documentation updates and a migration note in the release notes identifying potential source breakages and suggested remediation steps.

- **FR-009**: Iterators scope (v1 deferral): Iterator and async-iterator methods are out of scope for this feature. Using `try`/`catch`/`finally` within iterator or async-iterator methods is disallowed in v1; the compiler MUST emit a diagnostic (e.g., "try/catch/finally not supported in iterators (deferred)"). Future support to be specified in a separate feature.

- **FR-010**: Throw expressions (v1) — The language MUST support C#-style throw expressions in all contexts permitted by the latest stable C# version (e.g., null‑coalescing, conditional operator arms, expression‑bodied members). Requirements:
   - Grammar: introduce a `throwExpression` production that parses `throw` followed by an expression; statement‑form `throw;` remains statement‑only and is not a throw expression.
   - AST: add `ThrowExp` with field `Expression Exception` (required). Rethrow (`throw;`) remains represented by the existing `ThrowStatement` with no expression.
   - Semantics: the operand of a throw expression MUST be (or be convertible to) `System.Exception`; the throw expression has bottom/never type and participates in flow analysis consistent with C#.
   - IL: emit code to evaluate the operand followed by `throw`; structural IL tests should treat throw expressions equivalently to statement `throw` in generated opcodes.

- **FR-011**: AST modeling policy (this feature) — Represent all exception‑handling semantics as first‑class AST nodes and typed properties defined in `AstMetamodel`. Do NOT introduce open‑ended annotation bags or string‑keyed metadata on nodes. The only allowed annotations are existing non‑semantic infrastructure (e.g., source locations/trivia). Any additional metadata must be declared in the metamodel and generated via the AST generator.

### Key Non-functional Requirements
- **NFR-001**: Performance budget — No measurable regression on macrobenchmarks for the non-exceptional path. Measure using the repository's macrobenchmark suite; changes pass if there is no statistically significant slowdown versus baseline (e.g., Mann–Whitney U test p ≥ 0.05). Investigate any significant regressions; waivers require explicit justification.
- **NFR-002**: The IL emitter MUST produce handler metadata compatible with the runtime (CLR-style handlers if targeting .NET). The emitter should use the canonical instructions (`leave`, `endfinally`, `throw`, `rethrow` or their equivalents) that the target VM expects. For async state-machine rewrites involving try/catch/finally, the IL emitter MUST match Roslyn's IL byte-for-byte.
 - **NFR-003**: IL test baseline pinning — Execute IL structural and async byte-for-byte equality tests using the .NET SDK version specified in `global.json` (using the SDK’s bundled Roslyn). When `global.json` changes, re-baseline golden IL outputs as needed.

### Key Entities *(this feature involves AST/IR entities)*
- **TryStatement**: Represents the top-level try node in AST.
- **CatchClause**: Represents each catch with optional type, identifier and filter.
- **FinallyBlock**: Block executed on exit from try/catch.
- **ExceptionDispatch semantics**: (internal concept) tracking semantics necessary to preserve stack traces on rethrow.

---

## Review & Acceptance Checklist
*GATE: Implementation is not considered complete until all items below are satisfied by automated tests and code review.*

### Content Quality
- [x] Feature name and user intent are clear
- [x] Input (user description) preserved
- [ ] All mandatory spec sections completed (this file)

### Requirement Completeness
- [ ] No remaining [NEEDS CLARIFICATION] markers (owner must resolve before implementation)
- [ ] Requirements are testable and have associated tests
- [ ] Success criteria are measurable (parser/AST/IL/runtime tests exist)
- [ ] Scope is clearly bounded (parser + AST + IL + tests + docs)
- [ ] Dependencies and assumptions identified (runtime target, C# version, keyword handling: reserved as hard keywords, exception model mapping: CLR System.Exception)
- [ ] Dependencies and assumptions identified (runtime target, C# version, keyword handling: reserved as hard keywords, exception model mapping: CLR System.Exception, iterators deferred in v1 — no try/catch/finally in iterators)
 - [ ] Dependencies and assumptions identified (IL golden tests pinned to SDK in `global.json`; re-baseline on SDK change)
 - [ ] Performance gate defined and enforceable (macrobench “no measurable regression” policy; failure threshold via statistical significance test)
 - [ ] AST modeling policy enforced (no ad‑hoc annotations; first‑class nodes/typed fields only; metamodel‑declared)

---

## Execution Status
- [x] User description parsed
- [x] Key concepts extracted (parser, AST, semantic, IL)
- [x] Ambiguities marked
- [x] User scenarios defined
- [x] Requirements drafted
- [ ] Entities added to `AstMetamodel` (implementation task)
- [ ] Review checklist passed

---

## Implementation Plan (high level tasks)
The tasks below map the minimal work to implement the feature end-to-end. Each task should be split across smaller PRs if necessary; prefer small, reviewable commits.

1. Grammar & Lexer
   - Add keywords/tokens: `try`, `catch`, `finally`, `when` (if not already reserved) to `src/parser/grammar/FifthLexer.g4`.
   - Add a `tryStatement` grammar production to `src/parser/grammar/FifthParser.g4` that mirrors C# try/catch/finally forms but uses Fifth-style exception binding in catch parameters (`catchClause: 'catch' '(' Identifier ':' Type ( 'when' '(' Expression ')' )? ')' | 'catch' '(' Type ')' | 'catch' '{' Block '}'`).
   - Add parser-level tests: `src/parser/grammar/test_samples/try-catch-01.5th`, etc.
   - Add parser-level tests that include `catch (ex: System.Exception)`, `catch (System.Exception)` and `catch { ... }` samples to validate both bound and unnamed typed catches.
   - Add a `throwExpression` rule (C#-style) and enable it in contexts allowed by C#: null‑coalescing, conditional operator, expression‑bodied members; add samples exercising these contexts.

2. AST Model
   - Update `src/ast-model/AstMetamodel.cs` to add `TryStatement`, `CatchClause`, and `FinallyBlock` entries.
   - Run generator: `just run-generator` and validate generated builders in `src/ast-generated/`.
   - Add `ThrowExp` node with `Expression Exception`.

3. AST Builder
   - Update `src/parser/AstBuilderVisitor.cs` to construct `TryStatement` nodes including catch clauses and optional filters.
   - Add unit tests under `test/ast-tests/` validating the AST shape for a set of sample inputs.
   - Implement construction of `ThrowExp` for throw expressions; ensure `throw;` remains a `ThrowStatement`.

4. Semantic Analysis
   - Add semantic checks to ensure catch types are compatible with the runtime exception base type and that filter expressions are boolean-convertible.
   - Add diagnostics for invalid catch declarations.
   - Validate throw expression operand type derives from `System.Exception` (or is convertible); enforce flow analysis rules for bottom/never type positions.

5. IL / PE Emitter
   - Implement code emission in `src/code_generator/PEEmitter.cs` or the existing emitter pipeline to create exception handler regions with appropriate opcodes (`leave`, `endfinally`, `throw`) and metadata (catch/filter/finally). Use Roslyn output as structural reference when authoring tests.
   - Implement the async state-machine emission to reproduce Roslyn's transformation exactly for methods that include try/catch/finally across await points. This includes reproducing local slot layout, synthesized fields, MoveNext method structure, and exception handling boundaries.
   - Add a test harness that compiles the same source with Roslyn and Fifth's emitter and performs a byte-for-byte IL comparison for async cases.
   - Ensure throw expressions emit operand evaluation followed by `throw` opcode; include IL structural tests covering throw expressions in coalescing/conditional contexts.

6. Runtime & Integration Tests
   - Add runtime tests under `test/runtime-integration-tests/` that exercise try/catch/finally behaviour (including nested handlers, filters, rethrow behaviour, exceptions in finally, and async interactions).
   - If Fifth has its own runtime beyond CLR, add tests validating equivalent observable behaviour.
   - Add runtime tests where throw expressions are evaluated (e.g., `x ?? throw new E()`), asserting thrown exception types and messages.

7. Docs & Examples
   - Update `docs/syntax-samples-readme.md` and `learn5thInYMinutes.md` with concise try/catch/finally examples.
   - Add sample snippets under `test/` and `src/parser/grammar/test_samples/`.
   - Document throw expressions with examples (null‑coalescing and conditional operator arms).

8. CI & Validation
   - Add parser-checker-friendly samples to the validator's include list. Run `scripts/validate-examples.fish` to ensure new examples parse.
   - Ensure new tests are covered by `dotnet test test/syntax-parser-tests/`, `dotnet test test/ast-tests/`, and `dotnet test test/runtime-integration-tests/` as appropriate.
   - Run IL golden comparisons using the SDK pinned in `global.json`; update baselines when the pinned SDK changes.

---

## Testing & Validation Plan (concrete tests)
- Parser tests (syntax-parser-tests):
  - `TryCatchFinally_Syntax_01.5th`: simple try/finally parses
  - `TryCatchFinally_Syntax_02.5th`: multiple catch clauses parse (`catch (ex: System.Exception)`, `catch (System.Exception)`, `catch { }`)
  - `TryCatchFinally_Syntax_03.5th`: catch with filter (`catch (ex: System.Exception) when (ex.Message != null)`) parses
   - `ThrowExpression_Syntax_01.5th`: `a ?? throw new System.Exception("x")` parses
   - `ThrowExpression_Syntax_02.5th`: conditional operator arm `cond ? x : throw new E()` parses

- AST tests (ast-tests):
  - `TryStatement_AstShape_01`: verifies TryBlock, CatchClauses, FinallyBlock are present and typed correctly
   - `ThrowExpression_AstShape_01`: `ThrowExp` node created with `Exception` child populated
   - `NoAdHocAnnotations_Contract`: nodes for `TryStatement`, `CatchClause`, `FinallyBlock`, and `ThrowExp` expose required typed fields only; no custom annotation bags are used

- Semantic tests:
  - `CatchNonExceptionType_Error`: using `catch (x: int)` must produce a compile error
  - `FilterMustBeBoolean_Error`: `catch (e: Exception) when (123)` must be a type error
  - `CatchBinding_Syntax`: `catch (e: System.Exception)` populates `ExceptionIdentifier` and `ExceptionType` in the AST as expected.
   - `UnreachableCatch_Error`: a broader earlier catch makes a later typed catch unreachable → compile-time error
   - `ThrowExpression_OperandType_Error`: operand not deriving from `System.Exception` triggers diagnostic

- IL structural tests:
  - `TryFinally_ILLayout`: Ensure handler regions and `endfinally`/`leave` patterns are present.
  - `TryCatch_Filter_IL`: Ensure `filter` clauses are emitted when source uses `when` and handled structurally like Roslyn.
   - Baseline: perform all IL comparisons using the .NET SDK version from `global.json`.
   - `ThrowExpression_IL`: Ensure operand evaluation then `throw` opcode emitted in coalescing/conditional contexts.
 - Performance (macrobench) tests:
    - `Macro_NoRegression_NonExceptional`: Run the repository macrobenchmark suite; fail if there is a statistically significant slowdown vs baseline (e.g., Mann–Whitney U p < 0.05). Document any waivers.

- Runtime integration tests (runtime-integration-tests):
  - `FinallyAlwaysExecutes`: verifies finally always runs for return/throw paths
  - `RethrowPreservesStackTrace`: `throw;` preserves stack trace while `throw ex;` does not (compare stack traces or use ExceptionDispatchInfo semantics to assert preservation)
  - `ExceptionMapping_Emission`: Fifth exception types are emitted as CLR types derived from System.Exception and validated in IL-emission tests.
   - `ThrowExpression_Runtime`: `a ?? throw new E()` throws `E` when `a` is null; conditional arm throw behaves as expected.

---

## Open Questions / Decisions (must be resolved before implementation)
- 1. Keyword handling: reserve `try`, `catch`, `finally`, and `when` as hard keywords, or make them contextual? (back-compat trade-off) — Resolved: reserve as hard keywords (breaking change)
- 2. Async/await interaction: must the transformed state-machine IL match Roslyn byte-for-byte or only preserve observable behaviour? — Resolved: match Roslyn IL byte-for-byte
- 3. Exception filters: confirm whether filters must have access to the exception identifier in the filter expression and the exact scoping rules to follow (match C# semantics) — Resolved: exception identifier is in scope in filter and catch body (match C#)
- 4. If the Fifth runtime differs from CLR, define the mapping between Fifth exception model and the target runtime's exception model — Resolved: map directly to CLR types (use System.Exception family)

---

## Acceptance Criteria (concrete)
- Parser accepts all C#-style try/catch/finally forms in test suite (`syntax-parser-tests` green).
- AST builder produces `TryStatement` nodes and unit tests (`ast-tests`) asserting node shapes pass.
- Semantic analyzer rejects invalid catch-type uses and invalid filter expressions with documented diagnostics.
- IL-emitter structural tests compare the emitted handler metadata, handler kinds and critical opcodes to Roslyn's structural output and pass (allowing non-semantic differences such as local slot indices).
- End-to-end runtime tests (`runtime-integration-tests`) validate observable behaviour: catch selection order, filter semantics, finally execution, and rethrow stack-trace semantics.
- IL-emitter async IL equality tests: For representative async methods containing try/catch/finally across await points, the emitted IL MUST match Roslyn's IL byte-for-byte (textual comparison) and corresponding tests must pass. All thrown Fifth exceptions must be represented as CLR types derived from System.Exception per the mapping decision.

---

## Estimated effort
- Rough estimate (single engineer): 4–8 weeks of focused work, including tests and documentation. Matching Roslyn's async state-machine IL byte-for-byte increases design, testing, and validation effort. Break into small PRs: parser + AST + tests (2–4 days), semantic checks (1–2 days), IL-emitter changes + IL structural and async IL equality tests (2–4 weeks), runtime/integration tests and docs (4–7 days), review/merge/fixups (1–2 weeks).

---

## Next steps
1. Resolve all [NEEDS CLARIFICATION] items with stakeholders.
2. Create small focused PRs per the Implementation Plan, starting with parser + AST + generator run.
3. Add parser and AST unit tests; run `scripts/validate-examples.fish` and the test suites.

---
